import { useEffect, useCallback, useRef } from 'react';
import { useCanvasStore } from '@/lib/stores/canvas-store';
import { supabase, isSupabaseConfigured, DbNode, DbEdge } from '@/lib/supabase/client';
import { ConversationNode } from '@/lib/stores/canvas-store';
import { Edge } from '@xyflow/react';

const DEBOUNCE_DELAY = 1000; // 1 second auto-save

export function usePersistence() {
    const {
        nodes,
        edges,
        treeId,
        setTreeId,
        setSyncStatus,
        loadGraph,
        syncStatus
    } = useCanvasStore();

    const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
    const lastSavedRef = useRef<string>('');

    // Serialize current state to detect changes
    const serializeState = (nodes: ConversationNode[], edges: Edge[]) => {
        return JSON.stringify({
            nodes: nodes.map(n => ({
                id: n.id,
                position: n.position,
                data: n.data,
                type: n.type
            })),
            edges: edges.map(e => ({
                id: e.id,
                source: e.source,
                target: e.target
            }))
        });
    };

    // Save changes to Supabase
    const saveTree = useCallback(async () => {
        if (!isSupabaseConfigured() || !supabase) {
            console.warn('Supabase not configured, skipping save');
            return;
        }

        setSyncStatus('saving');

        try {
            const currentState = serializeState(nodes, edges);
            // If nothing changed since last save (and we aren't creating a new tree), skip
            if (treeId && currentState === lastSavedRef.current) {
                setSyncStatus('synced');
                return;
            }

            // 1. Ensure Tree Exists
            let currentTreeId = treeId;
            if (!currentTreeId) {
                const { data: tree, error: treeError } = await supabase
                    .from('trees')
                    .insert({ name: 'Untitled Conversation' })
                    .select()
                    .single();

                if (treeError) throw treeError;
                if (!tree) throw new Error('Failed to create tree');

                currentTreeId = tree.id;
                setTreeId(currentTreeId);
            } else {
                // Touch updated_at
                await supabase
                    .from('trees')
                    .update({ updated_at: new Date().toISOString() })
                    .eq('id', currentTreeId);
            }

            // 2. Upsert Nodes
            const dbNodes: DbNode[] = nodes.map(node => ({
                id: node.id,
                tree_id: currentTreeId!,
                parent_id: null, // We'd need to calculate this from edges if we want strict hierarchy in DB column, but edge table is enough for graph
                position_x: node.position.x,
                position_y: node.position.y,
                content_type: 'text',
                data: {
                    role: node.data.role,
                    content: node.data.content,
                    branchContext: node.data.branchContext
                },
                model_config: node.data.modelConfig || {},
                created_at: new Date().toISOString(), // won't override on upsert usually if configured right, but DB defaults handle this
                updated_at: new Date().toISOString()
            }));

            if (dbNodes.length > 0) {
                const { error: nodesError } = await supabase
                    .from('nodes')
                    .upsert(dbNodes);
                if (nodesError) throw nodesError;

                // Cleanup deleted nodes
                const activeNodeIds = dbNodes.map(n => n.id);
                await supabase
                    .from('nodes')
                    .delete()
                    .eq('tree_id', currentTreeId)
                    .not('id', 'in', activeNodeIds);
            }

            // 3. Upsert Edges
            const dbEdges: DbEdge[] = edges.map(edge => ({
                id: edge.id.length < 36 ? undefined : edge.id, // Let DB generate ID if it's a temp react-flow id, OR stick to ensuring we have UUIDs. 
                // React Flow IDs are often "xy-edge-..." so let's just generate new ones or rely on composite key?
                // Actually, our schema has UUID PK. 
                // Simpler: Delete all edges for tree and re-insert. Edges are lightweight.
                tree_id: currentTreeId!,
                source_id: edge.source,
                target_id: edge.target,
                created_at: new Date().toISOString()
            })).filter(e => e.id !== undefined) as any;
            // Issue: maintaining edge IDs is tricky if they are generated by RF as strings.
            // Strategy: Delete all edges for this tree and re-insert active ones. Safest for graph integrity.

            const { error: deleteEdgesError } = await supabase
                .from('edges')
                .delete()
                .eq('tree_id', currentTreeId);

            if (deleteEdgesError) throw deleteEdgesError;

            // React flow IDs might not be UUIDs, so we shouldn't send them as 'id' to a UUID column.
            // We'll let Supabase generate UUIDs for edges.
            const edgesToInsert = edges.map(edge => ({
                tree_id: currentTreeId,
                source_id: edge.source,
                target_id: edge.target
            }));

            if (edgesToInsert.length > 0) {
                const { error: edgesError } = await supabase
                    .from('edges')
                    .insert(edgesToInsert);
                if (edgesError) throw edgesError;
            }

            lastSavedRef.current = currentState;
            setSyncStatus('synced');
        } catch (error) {
            console.error('Save failed:', error);
            setSyncStatus('error');
        }
    }, [nodes, edges, treeId, setTreeId, setSyncStatus]);

    // Debounced Auto-save
    useEffect(() => {
        if (nodes.length === 0) return; // Don't save empty state immediately

        // Clear existing timeout
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }

        // Set status to unsaved/saving pending
        if (syncStatus === 'synced') {
            // potentially setSyncStatus('unsaved') here
        }

        timeoutRef.current = setTimeout(() => {
            saveTree();
        }, DEBOUNCE_DELAY);

        return () => {
            if (timeoutRef.current) clearTimeout(timeoutRef.current);
        };
    }, [nodes, edges, saveTree]); // Dependency on saveTree which depends on state

    // Load Tree Function
    const loadTree = useCallback(async (id: string) => {
        if (!supabase) return;
        setSyncStatus('saving'); // reuse loading state or add new one

        try {
            // Fetch tree
            const { data: tree, error: treeError } = await supabase
                .from('trees')
                .select('*')
                .eq('id', id)
                .single();

            if (treeError) throw treeError;

            // Fetch nodes
            const { data: dbNodes, error: nodesError } = await supabase
                .from('nodes')
                .select('*')
                .eq('tree_id', id);

            if (nodesError) throw nodesError;

            // Fetch edges
            const { data: dbEdges, error: edgesError } = await supabase
                .from('edges')
                .select('*')
                .eq('tree_id', id);

            if (edgesError) throw edgesError;

            // Transform to React Flow format
            const flowNodes: ConversationNode[] = (dbNodes || []).map(node => ({
                id: node.id,
                type: 'conversation',
                position: { x: node.position_x, y: node.position_y },
                data: {
                    role: node.data.role,
                    content: node.data.content,
                    branchContext: node.data.branchContext,
                    modelConfig: node.model_config
                }
            }));

            const flowEdges: Edge[] = (dbEdges || []).map(edge => ({
                id: edge.id, // UUID from DB
                source: edge.source_id,
                target: edge.target_id,
                type: 'smoothstep',
                animated: true
            }));

            setTreeId(id);
            loadGraph(flowNodes, flowEdges);
            lastSavedRef.current = serializeState(flowNodes, flowEdges);
            setSyncStatus('synced');

        } catch (error) {
            console.error('Load failed:', error);
            setSyncStatus('error');
        }
    }, [setTreeId, loadGraph, setSyncStatus]);

    return { saveTree, loadTree };
}
